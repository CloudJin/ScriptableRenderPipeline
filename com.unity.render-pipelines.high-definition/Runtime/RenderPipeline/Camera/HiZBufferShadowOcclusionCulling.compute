//--------------------------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------------------------
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"
struct InstanceData
{
	float3 boundsCenter;         // 3
	float3 boundsExtents;        // 6
};
struct DebugData
{
	float4 mipmap;
	float4 mipmapOffsetSize;
	float4 minMaxXY;
};
//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------
#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols
//--------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------
#define THREAD_GROUP_SIZE_X 64
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 1
#define LOD00_RANGE 500
#define LOD01_RANGE 2000
//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
CBUFFER_START(cb)
    float4x4 _UNITY_MATRIX_MVP1;
	float4x4 _UNITY_MATRIX_MVP2;
	float4x4 _UNITY_MATRIX_MVP3;
	float4x4 _UNITY_MATRIX_MVP4;

	float3 _ViewerPosition;
	float2 _ViewportSize;	
	
	uint _UseHighPrecision;
	uint _CascadeCount;
	uint _IsDirectional;
CBUFFER_END

RW_TEXTURE2D_X(float, _DepthMipChain);
RW_TEXTURE2D_X(float, _ShadowmapPyramid);
//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
StructuredBuffer<InstanceData> _InstanceDataBuffer;
StructuredBuffer<uint4> _MipmapOffset;
RWStructuredBuffer<uint> _isCascadeVisibleBuffer;
RWStructuredBuffer<DebugData> _debugBufferEx;
//--------------------------------------------------------------------------------------
// Kernels & Functions
//--------------------------------------------------------------------------------------
#if UNITY_REVERSED_Z
# define MIN_DEPTH(l, r) max(l, r)
#else
# define MIN_DEPTH(l, r) min(l, r)
#endif
inline uint IsViewerOutsideObjBounds(float3 pos, float3 minPos, float3 maxPos)
{
    float boundsSize = distance(maxPos, minPos);
    return ((distance(pos, maxPos) > boundsSize)
            + (distance(pos, minPos) > boundsSize));
}

inline float GatherMinDepth4Point(float2 minXY, float2 maxXY, uint mip)
{
	float2 scale = _ViewportSize / _MipmapOffset[0].zw;
	float2 mipmapTextureSize = float2(_MipmapOffset[mip].zw);
	uint2 offset = _MipmapOffset[mip].xy;
	int2 corner0 = floor(float2(minXY.x, minXY.y) * mipmapTextureSize * scale) + offset;
	int2 corner1 = floor(float2(minXY.x, maxXY.y) * mipmapTextureSize * scale) + offset;
	int2 corner2 = floor(float2(maxXY.x, minXY.y) * mipmapTextureSize * scale) + offset;
	int2 corner3 = floor(float2(maxXY.x, maxXY.y) * mipmapTextureSize * scale) + offset;
		
	// uint2 corner0 = float2(floor(minXY.x * mipmapTextureSize.x), floor(minXY.y * mipmapTextureSize.y)) + offset;
	// uint2 corner1 = float2(floor(minXY.x * mipmapTextureSize.x), ceil(maxXY.y * mipmapTextureSize.y)) + offset;
	// uint2 corner2 = float2(ceil(maxXY.x * mipmapTextureSize.x), floor(minXY.y * mipmapTextureSize.y)) + offset;
	// uint2 corner3 = float2(ceil(maxXY.x * mipmapTextureSize.x), ceil(maxXY.y * mipmapTextureSize.y)) + offset;
		
	float4 depth;
	depth.x = _ShadowmapPyramid[COORD_TEXTURE2D_X(corner0)];
	depth.y = _ShadowmapPyramid[COORD_TEXTURE2D_X(corner1)];
	depth.z = _ShadowmapPyramid[COORD_TEXTURE2D_X(corner2)];
	depth.w = _ShadowmapPyramid[COORD_TEXTURE2D_X(corner3)];
	float HiZdepth = min(min(depth.x, depth.y), min(depth.z, depth.w));  
	//HiZdepth = max(max(depth.x, depth.y), max(depth.z, depth.w));  
	HiZdepth *= 2;
	return HiZdepth;
}

inline float GatherMinDepth(float2 minXY, float2 maxXY, uint mip)
{
	float2 mipmapTextureSize = float2(_MipmapOffset[mip].zw); 
	float2 offset = _MipmapOffset[mip].xy;
	float2 scale = _ViewportSize / _MipmapOffset[0].zw;
	int2 cornerMin = floor(minXY * mipmapTextureSize * scale + offset);
	int2 cornerMax = floor(maxXY * mipmapTextureSize * scale + offset);
	//int2 cornerMin = round(minXY * mipmapTextureSize * scale + offset);
	//int2 cornerMax = floor(maxXY * mipmapTextureSize * scale + offset);
		
	float HiZdepth = 1;
	for(int y = cornerMin.y; y <= cornerMax.y; ++y)
	{
		for(int x = cornerMin.x; x <= cornerMax.x; ++x)
		{
			int2 xy = int2(x, y);
			HiZdepth = min(HiZdepth, _ShadowmapPyramid[COORD_TEXTURE2D_X(xy)]);
		}  
	}
	HiZdepth *= 2;	
	return HiZdepth;
}

inline uint isCascadeVisibleFromDepth(float clipMinZ, float depth)
{
	return (1 - clipMinZ) >= depth - 0.000015; // last is an epsilon
}

// Hi-Z Culling
inline uint isCascadeVisibleAfterOcclusionCulling(InstanceData instance, float clipMinX, float clipMaxX, float clipMinY, float clipMaxY, float clipMinZ, int id)
{
    // Change it to 0 - 1 range 
    float2 minXY = float2(clipMinX, clipMinY) * 0.5f + 0.5f;
    float2 maxXY = float2(clipMaxX, clipMaxY) * 0.5f + 0.5f;
    minXY = clamp(minXY, 0, 1);
	maxXY = clamp(maxXY, 0, 1);
	
    // Calculate hi-Z buffer mip
    int2 size = (maxXY - minXY) * _ViewportSize.xy;
    //float mip = ceil(log2(max(size.x, size.y) / 2.0f));
	float mip = ceil(log2(max(size.x, size.y)));
    mip = clamp(mip, 0, 10);
    
    // Texel footprint for the lower (finer-grained) level
    // float  level_lower = max(mip - 1, 0);
    // float2 scale = exp2(-level_lower);
    // float2 a = floor(minXY * scale);
    // float2 b = ceil(maxXY * scale);
    // float2 dims = b - a;
    
    // // Use the lower level if we only touch <= 2 texels in both dimensions
    // if (dims.x <= 2 && dims.y <= 2)
    // {
        // mip = level_lower;
    // }
    
	float HiZdepth = 1;  
	HiZdepth = GatherMinDepth4Point(minXY, maxXY, mip);
	HiZdepth = _UseHighPrecision && isCascadeVisibleFromDepth(clipMinZ, HiZdepth) > 0.0f? GatherMinDepth(minXY, maxXY, mip - 1): HiZdepth;
	HiZdepth = _UseHighPrecision && isCascadeVisibleFromDepth(clipMinZ, HiZdepth) > 0.0f? GatherMinDepth(minXY, maxXY, mip - 2): HiZdepth;
	
	_debugBufferEx[id].mipmap.x = mip;
	_debugBufferEx[id].mipmap.y = 1 - clipMinZ;
	_debugBufferEx[id].mipmap.z = HiZdepth;
	_debugBufferEx[id].minMaxXY.xy = minXY;
	_debugBufferEx[id].minMaxXY.zw = maxXY;
	_debugBufferEx[id].mipmapOffsetSize.xy = _MipmapOffset[mip].xy;
	_debugBufferEx[id].mipmapOffsetSize.zw = _MipmapOffset[mip].zw;
		
    return isCascadeVisibleFromDepth(clipMinZ, HiZdepth); 
}

inline uint isVisibleAfterFrustumCulling(float4 clipPos)
{
    return (clipPos.z > clipPos.w 
            || clipPos.x < -clipPos.w 
            || clipPos.x > clipPos.w 
            || clipPos.y < -clipPos.w 
            || clipPos.y > clipPos.w) 
            ? 0 : 1;
}
inline uint DetailCulling(float clipMinX, float clipMaxX, float clipMinY, float clipMaxY)
{
	int2 cornerMin = round(float2(clipMinX, clipMinY) * _ViewportSize); 
	int2 cornerMax = round(float2(clipMaxX, clipMaxY) * _ViewportSize);
	return cornerMin.x == cornerMax.x || cornerMin.y == cornerMax.y? 0: 1;
}

inline uint CalculateMinZ(float4 corner[8], float clipMin[3], float clipMax[2], float4x4 MVP)
{
	float4 clipPos = mul(MVP, corner[0]);
    uint isInFrustum = isVisibleAfterFrustumCulling(clipPos);
    clipPos.xyz = clipPos.xyz / clipPos.w;
    float clipMinX = clipPos.x;
    float clipMaxX = clipPos.x;
    float clipMinY = clipPos.y;
    float clipMaxY = clipPos.y;
    float clipMinZ = clipPos.z;
    //float minDistanceToCamera = distance(instance.boundsCenter.xyz, _ViewerPosition.xyz);
    [unroll]
    for (int i = 1; i < 8; i++)
    {
        clipPos = mul(MVP, corner[i]);
		
        // For Frustum
        isInFrustum = saturate(isInFrustum + isVisibleAfterFrustumCulling(clipPos));
        // For HiZ
        clipPos.xyz = clipPos.xyz / clipPos.w;
        clipMinX = min(clipPos.x, clipMinX);
        clipMaxX = max(clipPos.x, clipMaxX);
        clipMinY = min(clipPos.y, clipMinY);
        clipMaxY = max(clipPos.y, clipMaxY);
        clipMinZ = min(clipPos.z, clipMinZ);
    }
	clipMin[0] = clipMinX;
	clipMin[1] = clipMinY;
	clipMin[2] = clipMinZ;
	clipMax[0] = clipMaxX;
	clipMax[1] = clipMaxY;
	return isInFrustum;
}
//--------------------------------------------------------------------------------------
// Kernels
//--------------------------------------------------------------------------------------
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
inline void CSMain (
        in uint3 _dispatchThreadID : SV_DispatchThreadID, // DispatchThreadID  = dot(GroupID, numthreads) + GroupThreadId;
        in uint  _groupIndex       : SV_GroupIndex, // uint GroupIndex = unique index of a thread inside a group
        in uint3 _groupID          : SV_GroupID, // GroupID = index for each dimension inside a ThreadGroupCount 
        in uint3 _groupThreadID    : SV_GroupThreadID // uint3 GroupThreadId = indices for each dimension inside a group of the current thread
    )
{
    // Calculate the instance index, only correct if the THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z
	// and dipathed group num Y and Z are all 1. 
    uint tID = _dispatchThreadID.x;
    // Reset the visible state
    _isCascadeVisibleBuffer[tID] = 0;
    //_ShadowisCascadeVisibleBuffer[tID] = 0;
    // Get the instance data
    InstanceData instance = _InstanceDataBuffer[tID];
    // Check if the instance is visible
    float3 minPos = instance.boundsCenter - instance.boundsExtents;
    float3 maxPos = instance.boundsCenter + instance.boundsExtents + 0.01f;
	
    float4 boxCorners[8];
    boxCorners[0] = float4(minPos.x, minPos.y, minPos.z, 1.0);
    boxCorners[1] = float4(minPos.x, minPos.y, maxPos.z, 1.0);
    boxCorners[2] = float4(minPos.x, maxPos.y, minPos.z, 1.0);
    boxCorners[3] = float4(minPos.x, maxPos.y, maxPos.z, 1.0);
    boxCorners[4] = float4(maxPos.x, minPos.y, minPos.z, 1.0);
    boxCorners[5] = float4(maxPos.x, minPos.y, maxPos.z, 1.0);
    boxCorners[6] = float4(maxPos.x, maxPos.y, minPos.z, 1.0);
    boxCorners[7] = float4(maxPos.x, maxPos.y, maxPos.z, 1.0);
	
	float clipMin[3];
	float clipMax[2];
	
	float4x4 MVP[4];
	MVP[0] = _UNITY_MATRIX_MVP1;
	MVP[1] = _UNITY_MATRIX_MVP2;
	MVP[2] = _UNITY_MATRIX_MVP3;
	MVP[3] = _UNITY_MATRIX_MVP4;
	
	uint isVisible = 0;
	[unroll]
	for (int i = 0; i != 4; ++i)
	{
		uint isInFrustum = i < _CascadeCount? CalculateMinZ(boxCorners, clipMin, clipMax, MVP[i]): 0;
		
		// We only cull instances where the camera doesn't intersect the instance 
		// bounds. If the camera is inside the bounds we want to render the object
		uint isCascadeVisible = isVisible;
		uint isViewerOutsideObj = _IsDirectional == 0? IsViewerOutsideObjBounds(_ViewerPosition, minPos, maxPos): 1;
		uint skipCalculate = isViewerOutsideObj && isCascadeVisible == 0 && i < _CascadeCount? 1: 0;
		// Do we pass the frustum culling...?
		isCascadeVisible *= isInFrustum * skipCalculate;	
		isCascadeVisible *= (isCascadeVisible > 0 && !skipCalculate)? DetailCulling(clipMin[0], clipMax[0], clipMin[1], clipMax[1]): 1;
		
		// Do we pass the occlusion culling...?
		isCascadeVisible *= (isCascadeVisible > 0 && !skipCalculate)? isCascadeVisibleAfterOcclusionCulling(instance, clipMin[0], clipMax[0], clipMin[1], clipMax[1], clipMin[2], tID): 1;

		isVisible = isCascadeVisible > 0? 1: isVisible;
	}
    
    // Output
    _isCascadeVisibleBuffer[tID] = isVisible;
}