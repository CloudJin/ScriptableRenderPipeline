//--------------------------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------------------------
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/TextureXR.hlsl"

#define Enable_Debug 1
#define Enable_Bit 0

struct InstanceData
{
	float3 boundsCenter;  
	float padding0;
	float3 boundsExtents;        
	float padding1;
};
#if Enable_Debug
struct DebugData
{
	float4 mipmapDepth;
	float4 mipmapOffsetSizeDepth;
	float4 minMaxXYInCameraSpace;
	
	float4 mipmapShadowmap;
	float4 mipmapOffsetSizeShadowmap;
	float4 minMaxXYInLightSpace;
};
#endif

struct ShadowVolume
{
	// the AABB is in the light space NDC
	float3 boundsCenter;
	uint cascadeIndex;
	float3 boundsExtents;  
	float depth;
	//float nearestDepth;
};
//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------
#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols
//--------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------
#define THREAD_GROUP_SIZE_X 64
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 1

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
CBUFFER_START(cb)
    float4x4 _UNITY_MATRIX_VP1;
	float4x4 _UNITY_MATRIX_VP2;
	float4x4 _UNITY_MATRIX_VP3;
	float4x4 _UNITY_MATRIX_VP4;
	float4x4 _UNITY_MATRIX_LIGHT_TO_CAMERA1;
	float4x4 _UNITY_MATRIX_LIGHT_TO_CAMERA2;
	float4x4 _UNITY_MATRIX_LIGHT_TO_CAMERA3;
	float4x4 _UNITY_MATRIX_LIGHT_TO_CAMERA4;

	float3 _CamPosition;
	float3 _ViewerPosition;
	float2 _ViewportSize;	
	int2 _Resolution;
	
	uint _UseHighPrecision;
	int _CascadeCount;
	uint _IsDirectional;
	
CBUFFER_END

uniform uint _isShadowCaster;			// this dispatch is for shadow caster or not
uniform uint _lightIndex;
#if Enable_Debug
uniform uint _debugShadow;
#endif

RW_TEXTURE2D_X(float, _DepthPyramid);
RW_TEXTURE2D(float, _ShadowmapPyramid); 
//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
StructuredBuffer<InstanceData> _InstanceDataBuffer;
//StructuredBuffer<float4x4> _MatrixVP;
//StructuredBuffer<float4x4> _MatrixLightToCamera;
StructuredBuffer<uint4> _ShadowmapMipmapOffset;
StructuredBuffer<uint4> _DepthMipmapOffset;
#if Enable_Bit
RWByteAddressBuffer _IsVisibleBuffer;
#else
RWStructuredBuffer<uint> _IsVisibleBuffer;
#endif
#if Enable_Debug
RWStructuredBuffer<DebugData> _debugBuffer; 
#endif
//--------------------------------------------------------------------------------------
// Kernels & Functions
//--------------------------------------------------------------------------------------
#if UNITY_REVERSED_Z    // DX
# define MIN_DEPTH(l, r) max(l, r)
# define MAX_DEPTH(l, r) min(l, r)
#else                   // opengl
# define MIN_DEPTH(l, r) min(l, r)
# define MAX_DEPTH(l, r) max(l, r)
#endif

inline uint IsViewerOutsideObjBounds(float3 pos, float3 minPos, float3 maxPos)
{
    float boundsSize = distance(maxPos, minPos);
    return ((distance(pos, maxPos) > boundsSize)
            + (distance(pos, minPos) > boundsSize));
}

ShadowVolume CalculateShadowVolume(float2 clipMin, float2 clipMax, float farestDepth, float nearestDepth)
{
	ShadowVolume volume;
	volume.boundsCenter = float3((clipMin.x + clipMax.x) / 2, (clipMin.y + clipMax.y) / 2, (farestDepth + nearestDepth) / 2);
	volume.boundsExtents = float3(abs(clipMax.x - clipMin.x) / 2, abs(clipMax.y - clipMin.y) / 2, abs(farestDepth - nearestDepth) / 2);
	volume.depth = farestDepth;
	//volume.nearestDepth = nearestDepth;
	return volume;
}

inline void GatherMinDepth4PointInShadowmap(float2 minXY,
    float2 maxXY,
    uint mip,
    int cascadeIndex,
    out int cascadeIndexShadowVolume,
    out float outClosestDepth,
    out float outFarestDepth,
    int id)
{
	float2 mipmapTextureSize = float2(_ShadowmapMipmapOffset[mip + cascadeIndex * 10].zw);
	uint2 offset = _ShadowmapMipmapOffset[mip + cascadeIndex * 10].xy;
	int2 corner0 = floor(float2(minXY.x, minXY.y) * mipmapTextureSize) + offset;
	int2 corner1 = floor(float2(minXY.x, maxXY.y) * mipmapTextureSize) + offset;
	int2 corner2 = floor(float2(maxXY.x, minXY.y) * mipmapTextureSize) + offset;
	int2 corner3 = floor(float2(maxXY.x, maxXY.y) * mipmapTextureSize) + offset;

	float4 depth;
    depth.x = (_ShadowmapPyramid[(corner0)]);
    depth.y = (_ShadowmapPyramid[(corner1)]);
    depth.z = (_ShadowmapPyramid[(corner2)]);
    depth.w = (_ShadowmapPyramid[(corner3)]);
    float farestDepth = MIN_DEPTH(MIN_DEPTH(depth.x, depth.y), MIN_DEPTH(depth.z, depth.w));
    float closestDepth = MAX_DEPTH(MAX_DEPTH(depth.x, depth.y), MAX_DEPTH(depth.z, depth.w));

	cascadeIndexShadowVolume = cascadeIndex;
    outClosestDepth = closestDepth;
    outFarestDepth = farestDepth;
}

inline float GatherFarestDepth4PointInDepthBuffer(float2 minXY, float2 maxXY, uint mip, int id)
{
	//float2 scale = _ViewportSize / _DepthMipmapOffset[0].zw;
    float2 scale = float2(1, 1);
	float2 mipmapTextureSize = float2(_DepthMipmapOffset[mip].zw);
	uint2 offset = _DepthMipmapOffset[mip].xy;
	int2 corner0 = floor(float2(minXY.x, minXY.y) * mipmapTextureSize * scale) + offset;
	int2 corner1 = floor(float2(minXY.x, maxXY.y) * mipmapTextureSize * scale) + offset;
	int2 corner2 = floor(float2(maxXY.x, minXY.y) * mipmapTextureSize * scale) + offset;
	int2 corner3 = floor(float2(maxXY.x, maxXY.y) * mipmapTextureSize * scale) + offset;

	float4 depth;
    depth.x = Linear01Depth(_DepthPyramid[COORD_TEXTURE2D_X(corner0)], _ZBufferParams);
    depth.y = Linear01Depth(_DepthPyramid[COORD_TEXTURE2D_X(corner1)], _ZBufferParams);
    depth.z = Linear01Depth(_DepthPyramid[COORD_TEXTURE2D_X(corner2)], _ZBufferParams);
    depth.w = Linear01Depth(_DepthPyramid[COORD_TEXTURE2D_X(corner3)], _ZBufferParams);
    float farestDepth = MIN_DEPTH(MIN_DEPTH(depth.x, depth.y), MIN_DEPTH(depth.z, depth.w));
    float closestDepth = MAX_DEPTH(MAX_DEPTH(depth.x, depth.y), MAX_DEPTH(depth.z, depth.w));

#if Enable_Debug
    //_debugBuffer[id].mipmapDepth.x = mip;
    //_debugBuffer[id].mipmapDepth.y = farestDepth;
    //_debugBuffer[id].mipmapDepth.z = farestDepth;
	//_debugBuffer[id].minMaxXYInCameraSpace.xy = float2(farestDepth, nearestDepth);
#endif
    return farestDepth;
}

inline float GatherMinDepthInShadowmap(float2 minXY, float2 maxXY, int mip, int cascadeIndex, out float outClosestDepth)
{
	float2 mipmapTextureSize = float2(_ShadowmapMipmapOffset[mip + cascadeIndex * 10].zw); 
	float2 offset = _ShadowmapMipmapOffset[mip + cascadeIndex * 10].xy;
	int2 cornerMin = floor(minXY * mipmapTextureSize + offset);
	int2 cornerMax = floor(maxXY * mipmapTextureSize + offset);
		
#if UNITY_REVERSED_Z
	float farestDepth = 1.0f;
	float closestDepth = -10.0f;
#else
    float farestDepth = -1.0f;
    float closestDepth = 10.0f;
#endif
	for(int y = cornerMin.y; y <= cornerMax.y; ++y)
	{
		for(int x = cornerMin.x; x <= cornerMax.x; ++x)
		{
			int2 xy = int2(x, y);
			float depth = _ShadowmapPyramid[(xy)];
            closestDepth = MIN_DEPTH(closestDepth, depth);
            farestDepth = MAX_DEPTH(farestDepth, depth);
        }  
	}

    outClosestDepth = closestDepth;
	return farestDepth;
}

inline float GatherFarestDepthInDepthBuffer(float2 minXY, float2 maxXY, int mip) 
{
	//float2 scale = _ViewportSize / _DepthMipmapOffset[0].zw;
    float2 scale = float2(1, 1);
	float2 mipmapTextureSize = float2(_DepthMipmapOffset[mip].zw); 
	float2 offset = _DepthMipmapOffset[mip].xy;
	int2 cornerMin = floor(minXY * mipmapTextureSize * scale + offset);
    int2 cornerMax = ceil(maxXY * mipmapTextureSize * scale + offset);
    //int2 cornerMax = floor(maxXY * mipmapTextureSize * scale + offset);

#if UNITY_REVERSED_Z
	float farestDepth = -1.0f;
    float closestDepth = 10.0f;
#else
    float farestDepth = 1.0f;
    float closestDepth = -10.0f;
#endif
    
	for(int x = cornerMin.x; x <= cornerMax.x; ++x)
	{
		for(int y = cornerMin.y; y <= cornerMax.y; ++y)
		{
			int2 xy = int2(x, y);
			float depth = _DepthPyramid[COORD_TEXTURE2D_X(xy)];
            depth = Linear01Depth(depth, _ZBufferParams);
            farestDepth = MIN_DEPTH(farestDepth, depth);
            closestDepth = MAX_DEPTH(closestDepth, depth);
        }  
	}
    return farestDepth;
}

//The depth is linear, the range is [0, 1]
inline uint isCascadeVisibleFromDepth(float clipMinZ, float depth)
{
    return (clipMinZ) < depth + 0.000001 ? 1 : 0; // last is an epsilon
}

// The depth is linear, the range is [1, 0]
inline uint isCascadeVisibleFromShadowmap(float clipMinZ, float depth)
{
    return (clipMinZ) > depth - 0.000001 ? 1 : 0; // last is an epsilon
}

InstanceData TestReturnValue()
{
	InstanceData data;
	data.boundsCenter = float3(1, 1, 1);
	return data;
}

void TestReturnValue2(InstanceData data)
{
	//InstanceData data;
	data.boundsCenter = float3(1, 1, 1);
}

void TestReturnArray(float data[3])
{
	data[0] = 1;
	data[1] = 2;
	data[2] = 3;
}

// Hi-Z Culling
inline ShadowVolume isCascadeVisibleInShadowmap(int cascadeIndex, out uint visible, float3 clipMin, float3 clipMax, int id)
{
    // Change it to 0 - 1 range 
    float2 minXY = float2(clipMin.x, clipMin.y) * 0.5f + 0.5f;
    float2 maxXY = float2(clipMax.x, clipMax.y) * 0.5f + 0.5f;
    minXY = clamp(minXY, 0, 1);
	maxXY = clamp(maxXY, 0, 1);
	
    // Calculate hi-Z buffer mip
	int2 size = (maxXY - minXY) * _Resolution;
	int mip = ceil(log2(min(size.x, size.y))) - 1;
	int maxMip = ceil(log2(_Resolution.x)) - 1;
    mip = clamp(mip, 0, maxMip);
	
	float HiZdepth = 1;  
	float farestDepth = 0;
	uint cascadeIndexShadowVolume = 10;
	GatherMinDepth4PointInShadowmap(minXY, maxXY, mip,
        cascadeIndex, cascadeIndexShadowVolume,
        HiZdepth, farestDepth, id);
    //farestDepth = (_UseHighPrecision && (mip >= 1) && isCascadeVisibleFromShadowmap(clipMin.z, HiZdepth) < 1) ? GatherMinDepthInShadowmap(minXY, maxXY, mip - 1, cascadeIndex, HiZdepth) : HiZdepth;

    //farestDepth = (_UseHighPrecision && isCascadeVisibleFromDepth(clipMin.z, HiZdepth) > 0.0f && mip >= 2)? GatherMinDepthInShadowmap(minXY, maxXY, mip - 2, cascadeIndex, HiZdepth): HiZdepth;
	
    ShadowVolume shadowVolume = CalculateShadowVolume(clipMin.xy, clipMax.xy, farestDepth, HiZdepth);
	shadowVolume.cascadeIndex = HiZdepth > 0.0f? cascadeIndexShadowVolume: 10;
    visible = isCascadeVisibleFromShadowmap(clipMax.z, HiZdepth);
#if Enable_Debug
    if (_debugShadow && _isShadowCaster)
    {
		//mip = 0;
        _debugBuffer[id].mipmapShadowmap.x = mip;
        _debugBuffer[id].mipmapShadowmap.y = clipMin.z;
		//_debugBuffer[id].mipmapShadowmap.xy = float2(clipMinX, clipMinY); 
        _debugBuffer[id].mipmapShadowmap.z = HiZdepth;
        _debugBuffer[id].mipmapShadowmap.w = farestDepth;
		//_debugBuffer[id].mipmapShadowmap.zw = float2(clipMaxX, clipMaxY);
        _debugBuffer[id].minMaxXYInLightSpace.xy = minXY;
		//_debugBuffer[id].minMaxXYInLightSpace.xy = clipMin.xy;
        _debugBuffer[id].minMaxXYInLightSpace.zw = maxXY;
		//_debugBuffer[id].minMaxXYInLightSpace.zw = clipMax.xy;
		//_debugBuffer[id].minMaxXYInLightSpace.xyz = shadowVolume.boundsExtents;
        _debugBuffer[id].mipmapOffsetSizeShadowmap.xy = _ShadowmapMipmapOffset[mip + cascadeIndex * 10].xy;
        _debugBuffer[id].mipmapOffsetSizeShadowmap.zw = _ShadowmapMipmapOffset[mip + cascadeIndex * 10].zw;
    }
#endif
	return shadowVolume;
}

// Hi-Z Culling
inline uint isVisibleInDepthBuffer(float3 clipMin, float3 clipMax, int id)
{
    // Change it to 0 - 1 range 
    float2 minXY = float2(clipMin.x, clipMin.y) * 0.5f + 0.5f;
    float2 maxXY = float2(clipMax.x, clipMax.y) * 0.5f + 0.5f;
    minXY = clamp(minXY, 0, 1);
	maxXY = clamp(maxXY, 0, 1);
	
    // Calculate hi-Z buffer mip
	int2 size = (maxXY - minXY) *  _ViewportSize.xy;
	int mip = ceil(log2(max(size.x, size.y))) - 1;
	int maxMip = ceil(log2( _ViewportSize.x));
	//if (_isShadowCaster)
	//	mip = clamp(mip, 0, 7);
	//else 
		mip = clamp(mip, 0, 10);

    float farestDepth = -1;
    farestDepth = GatherFarestDepth4PointInDepthBuffer(minXY, maxXY, mip, id);
    if ((_UseHighPrecision > 0 && isCascadeVisibleFromDepth(clipMin.z, farestDepth) < 1 && mip > 1))
        farestDepth = GatherFarestDepthInDepthBuffer(minXY, maxXY, mip - 1);
    if ((_UseHighPrecision > 0 && isCascadeVisibleFromDepth(clipMin.z, farestDepth) < 1 && mip > 2))
        farestDepth = GatherFarestDepthInDepthBuffer(minXY, maxXY, mip - 2);

#if Enable_Debug
    if (_debugShadow == _isShadowCaster)
	//if (_debugShadow <= 0 && _isShadowCaster <= 0)
    {
		//mip = 0;
        _debugBuffer[id].mipmapDepth.x = mip;
        _debugBuffer[id].mipmapDepth.y = clipMin.z;
		//_debugBuffer[id].mipmapDepth.xy = float2(clipMinX, clipMinY);
        _debugBuffer[id].mipmapDepth.z = farestDepth;
		//_debugBuffer[id].mipmapDepth.zw = float2(clipMaxX, clipMaxY);
        _debugBuffer[id].minMaxXYInCameraSpace.xy = minXY;
        _debugBuffer[id].minMaxXYInCameraSpace.zw = maxXY;
		//_debugBuffer[id].minMaxXYInCameraSpace.xy = clipMin.xy;
		//_debugBuffer[id].minMaxXYInCameraSpace.zw = clipMax.xy;

		//_debugBuffer[id].minMaxXYInCameraSpace = float4(clipMin.x, clipMax.x, clipMin.y, clipMax.y);
        _debugBuffer[id].mipmapOffsetSizeDepth.xy = _DepthMipmapOffset[mip].xy;
        _debugBuffer[id].mipmapOffsetSizeDepth.zw = _DepthMipmapOffset[mip].zw;
    }
    //else
    //{
    //    _debugBuffer[id].mipmapDepth.x = mip;
    //    _debugBuffer[id].mipmapDepth.y = clipMin.z;
    //    _debugBuffer[id].mipmapDepth.z = farestDepth;
    //    _debugBuffer[id].mipmapOffsetSizeDepth.xy = _DepthMipmapOffset[mip].xy;
    //    _debugBuffer[id].mipmapOffsetSizeDepth.zw = _DepthMipmapOffset[mip].zw;
    //    _debugBuffer[id].minMaxXYInCameraSpace.xy = minXY;
    //    _debugBuffer[id].minMaxXYInCameraSpace.zw = maxXY;
    //}
#endif	
    //return HiZdepth > 0? isCascadeVisibleFromDepth(clipMinZ, HiZdepth): 0; 
    return isCascadeVisibleFromDepth(clipMin.z, farestDepth);
}


inline uint FrustumCulling(float4 clipPos)
{
    return (clipPos.z > clipPos.w 
            || clipPos.x < -clipPos.w 
            || clipPos.x > clipPos.w 
            || clipPos.y < -clipPos.w 
            || clipPos.y > clipPos.w) 
            ? 0 : 1;
}

inline uint DetailCulling(float3 clipMin, float3 clipMax)
{
	float2 minXY = float2(clipMin.x, clipMin.y) * 0.5f + 0.5f;
    float2 maxXY = float2(clipMax.x, clipMax.y) * 0.5f + 0.5f;
    minXY = clamp(minXY, 0, 1);
	maxXY = clamp(maxXY, 0, 1);
	
	int2 cornerMin = round(minXY * _Resolution); 
	int2 cornerMax = round(maxXY * _Resolution);
	return cornerMin.x == cornerMax.x || cornerMin.y == cornerMax.y? 0: 1;
}

inline uint DetailCullingInDepth(float3 clipMin, float3 clipMax)
{
	float2 minXY = float2(clipMin.x, clipMin.y) * 0.5f + 0.5f;
    float2 maxXY = float2(clipMax.x, clipMax.y) * 0.5f + 0.5f;
    minXY = clamp(minXY, 0, 1);
	maxXY = clamp(maxXY, 0, 1);
	
	int2 cornerMin = round(minXY * _ViewportSize); 
	int2 cornerMax = round(maxXY * _ViewportSize);
	return cornerMin.x == cornerMax.x || cornerMin.y == cornerMax.y? 0: 1;
}

inline uint CalculateMinMaxWithLinearZ(float4 corner[8], float4x4 matrixVP, out float3 outClipMin, out float3 outClipMax, uint id)
{
	float4 clipPos = mul(matrixVP, corner[0]);
    uint isInFrustum = FrustumCulling(clipPos);
    clipPos.xy = clipPos.xy / clipPos.w;
    clipPos.z = clipPos.w * _ZBufferParams.w;
    
    float clipMinX = clipPos.x;
    float clipMaxX = clipPos.x;
    float clipMinY = clipPos.y;
    float clipMaxY = clipPos.y;
    float clipMinZ = clipPos.z;
	float clipMaxZ = clipPos.z;
	
    [unroll]
    for (int i = 1; i < 8; i++)
    { 
		clipPos = mul(matrixVP, corner[i]);
        // For Frustum
        isInFrustum = saturate(isInFrustum + FrustumCulling(clipPos));
        // For HiZ
        clipPos.xy = clipPos.xy / clipPos.w;
        clipPos.z = clipPos.w * _ZBufferParams.w;
        
        clipMinX = min(clipPos.x, clipMinX);
        clipMaxX = max(clipPos.x, clipMaxX);
        clipMinY = min(clipPos.y, clipMinY);
        clipMaxY = max(clipPos.y, clipMaxY);
        clipMinZ = min(clipPos.z, clipMinZ);
		clipMaxZ = max(clipPos.z, clipMaxZ);
    }
	
	outClipMin.x = clipMinX;
	outClipMin.y = clipMinY;
	outClipMin.z = clipMinZ;
	outClipMax.x = clipMaxX;
	outClipMax.y = clipMaxY;
    outClipMax.z = clipMaxZ;
	return isInFrustum;
}


inline uint CalculateMinMax(float4 corner[8], float4x4 matrixVP, out float3 outClipMin, out float3 outClipMax, uint id)
{
    float4 clipPos = mul(matrixVP, corner[0]);
    uint isInFrustum = FrustumCulling(clipPos);
    clipPos.xyz = clipPos.xyz / clipPos.w;
    
    float clipMinX = clipPos.x;
    float clipMaxX = clipPos.x;
    float clipMinY = clipPos.y;
    float clipMaxY = clipPos.y;
    float clipMinZ = clipPos.z;
    float clipMaxZ = clipPos.z;
	
    [unroll]
    for (int i = 1; i < 8; i++)
    {
        clipPos = mul(matrixVP, corner[i]);
        // For Frustum
        isInFrustum = saturate(isInFrustum + FrustumCulling(clipPos));
        // For HiZ
        clipPos.xyz = clipPos.xyz / clipPos.w;
        
        clipMinX = min(clipPos.x, clipMinX);
        clipMaxX = max(clipPos.x, clipMaxX);
        clipMinY = min(clipPos.y, clipMinY);
        clipMaxY = max(clipPos.y, clipMaxY);
        clipMinZ = min(clipPos.z, clipMinZ);
        clipMaxZ = max(clipPos.z, clipMaxZ);
    }
	
    outClipMin.x = clipMinX;
    outClipMin.y = clipMinY;
    outClipMin.z = clipMinZ;
    outClipMax.x = clipMaxX;
    outClipMax.y = clipMaxY;
    outClipMax.z = clipMaxZ;
    return isInFrustum;
}

inline uint IsVisibleInDepthBuffer(ShadowVolume shadowVolume, int id)
{
	float4x4 matrixLight2CameraClip[4];
	matrixLight2CameraClip[0] = _UNITY_MATRIX_LIGHT_TO_CAMERA1;
	matrixLight2CameraClip[1] = _UNITY_MATRIX_LIGHT_TO_CAMERA2;
	matrixLight2CameraClip[2] = _UNITY_MATRIX_LIGHT_TO_CAMERA3;
	matrixLight2CameraClip[3] = _UNITY_MATRIX_LIGHT_TO_CAMERA4;
	
	float3 minShadowBoxPos = shadowVolume.boundsCenter - shadowVolume.boundsExtents;
	float3 maxShadowBoxPos = shadowVolume.boundsCenter + shadowVolume.boundsExtents;
	float4 shadowBoxCorners[8];
	shadowBoxCorners[0] = float4(minShadowBoxPos.x, minShadowBoxPos.y, minShadowBoxPos.z, 1.0);
	shadowBoxCorners[1] = float4(minShadowBoxPos.x, minShadowBoxPos.y, maxShadowBoxPos.z, 1.0);
	shadowBoxCorners[2] = float4(minShadowBoxPos.x, maxShadowBoxPos.y, minShadowBoxPos.z, 1.0);
	shadowBoxCorners[3] = float4(minShadowBoxPos.x, maxShadowBoxPos.y, maxShadowBoxPos.z, 1.0);
	shadowBoxCorners[4] = float4(maxShadowBoxPos.x, minShadowBoxPos.y, minShadowBoxPos.z, 1.0);
	shadowBoxCorners[5] = float4(maxShadowBoxPos.x, minShadowBoxPos.y, maxShadowBoxPos.z, 1.0);
	shadowBoxCorners[6] = float4(maxShadowBoxPos.x, maxShadowBoxPos.y, minShadowBoxPos.z, 1.0);
	shadowBoxCorners[7] = float4(maxShadowBoxPos.x, maxShadowBoxPos.y, maxShadowBoxPos.z, 1.0); 
	
	float3 clipMin, clipMax;
	uint isInFrustum = CalculateMinMaxWithLinearZ(shadowBoxCorners, matrixLight2CameraClip[shadowVolume.cascadeIndex], clipMin, clipMax, id);
	//uint isViewerOutsideObj = _IsDirectional == 0? IsViewerOutsideObjBounds(_ViewerPosition, minShadowBoxPos, maxShadowBoxPos): 1;
	uint isCascadeVisible = isInFrustum;	
	//isCascadeVisible *= (isCascadeVisible > 0)? DetailCullingInDepth(clipMin, clipMax): 1;

    
	//isCascadeVisible *= (isCascadeVisible > 0)? isCascadeVisibleInDepthBuffer(clipMinCameraSpace, clipMaxCameraSpace, id): 0;
	if (isCascadeVisible > 0)
        isCascadeVisible *= isVisibleInDepthBuffer(clipMin, clipMax, id);
	//isCascadeVisible *= (isCascadeVisible > 0)? isCascadeVisibleInDepthBuffer(clipMin, clipMax, id): 0;
	
	//_debugBuffer[id].minMaxXYInLightSpace.xyz = boundsExtents;
	//_debugBuffer[id].minMaxXYInCameraSpace.zw = clipMaxCameraSpace.xy;
	//_debugBuffer[id].minMaxXYInCameraSpace.xy  = clipMin.xy;
	//_debugBuffer[id].minMaxXYInCameraSpace.zw  = clipMax.xy;
    //_debugBuffer[id].mipmapDepth.xyz = clipMin;
	return isCascadeVisible;
}
//--------------------------------------------------------------------------------------
// Kernels
//--------------------------------------------------------------------------------------
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
inline void CSMain (
        in uint3 _dispatchThreadID : SV_DispatchThreadID, // DispatchThreadID  = dot(GroupID, numthreads) + GroupThreadId;
        in uint  _groupIndex       : SV_GroupIndex, // uint GroupIndex = unique index of a thread inside a group
        in uint3 _groupID          : SV_GroupID, // GroupID = index for each dimension inside a ThreadGroupCount 
        in uint3 _groupThreadID    : SV_GroupThreadID // uint3 GroupThreadId = indices for each dimension inside a group of the current thread
    )
{
    // Calculate the instance index, only correct if the THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z
	// and dipathed group num Y and Z are all 1. 
    uint tID = _dispatchThreadID.x;
#if !Enable_Bit
    // Reset the visible state
    //_IsVisibleBuffer[tID] = 0;
#endif	
    //_ShadowisCascadeVisibleBuffer[tID] = 0;
    // Get the instance data
    InstanceData instance = _InstanceDataBuffer[tID];
    // Check if the instance is visible
    float3 minPos = instance.boundsCenter - instance.boundsExtents;
    float3 maxPos = instance.boundsCenter + instance.boundsExtents + 0.01f;
    float4 boxCorners[8];
    boxCorners[0] = float4(minPos.x, minPos.y, minPos.z, 1.0);
    boxCorners[1] = float4(minPos.x, minPos.y, maxPos.z, 1.0);
    boxCorners[2] = float4(minPos.x, maxPos.y, minPos.z, 1.0);
    boxCorners[3] = float4(minPos.x, maxPos.y, maxPos.z, 1.0);
    boxCorners[4] = float4(maxPos.x, minPos.y, minPos.z, 1.0);
    boxCorners[5] = float4(maxPos.x, minPos.y, maxPos.z, 1.0);
    boxCorners[6] = float4(maxPos.x, maxPos.y, minPos.z, 1.0);
    boxCorners[7] = float4(maxPos.x, maxPos.y, maxPos.z, 1.0);

	float4x4 matrixVP[4];
	matrixVP[0] = _UNITY_MATRIX_VP1;
	matrixVP[1] = _UNITY_MATRIX_VP2;
	matrixVP[2] = _UNITY_MATRIX_VP3;
	matrixVP[3] = _UNITY_MATRIX_VP4;
	
	uint cascadeVisible[4];
	uint isVisible = 0;
	
#if Enable_Debug
	_debugBuffer[tID].mipmapShadowmap.z = -1;
#endif
	
	if (_isShadowCaster)
	{
		ShadowVolume shadowVolume;
		shadowVolume.cascadeIndex = 10;
		int cascadeIndexShadowVolume = -1;
		[unroll]
		for (int i = 0; i != 4; ++i)
		{
            if (i >= _CascadeCount)
                break;
            
            cascadeVisible[i] = 0;
			uint isInFrustum = 0;
			// Do we pass the frustum culling...?
			float3 clipMin, clipMax;
		    isInFrustum = CalculateMinMax(boxCorners, matrixVP[i], clipMin, clipMax, tID);
			//isInFrustum = i < _CascadeCount? CalculateMinMax(boxCorners, matrixVP[i], clipMin, clipMax, tID): 0;
			
			uint isViewerOutsideObj = 1;
			//if (_IsDirectional == 0)
			//	isViewerOutsideObj = IsViewerOutsideObjBounds(_ViewerPosition, minPos, maxPos);
			//isViewerOutsideObj = _IsDirectional == 0? IsViewerOutsideObjBounds(_ViewerPosition, minPos, maxPos): 1;
			uint skipCalculate = 1;
			if (isViewerOutsideObj > 0 && isVisible == 0)
				skipCalculate = 0;
			//skipCalculate = isViewerOutsideObj > 0 && isVisible == 0 && i < _CascadeCount? 0: 1;
			if (skipCalculate)
				continue;
			
			uint isCascadeVisible = 1;
			isCascadeVisible = isInFrustum;
			//isCascadeVisible = isInFrustum * (skipCalculate == 0? 1: 0);
			
			//if (isCascadeVisible > 0)
			//	isCascadeVisible *= DetailCulling(clipMin, clipMax);
			//isCascadeVisible *= (isCascadeVisible > 0)? DetailCulling(clipMin, clipMax): 1;
	#if Enable_Debug
			//_debugBuffer[tID].mipmapShadowmap.z = isCascadeVisible > 0? -1: _debugBuffer[tID].mipmapShadowmap.z;
			//_debugBuffer[tID].mipmapShadowmap.w = -1;
	#endif
			// Do we pass the shadow occlusion culling in light space?
			if (isInFrustum > 0)
			{
				uint visible = 0;
				ShadowVolume temp = isCascadeVisibleInShadowmap(i, visible, clipMin, clipMax, tID);
				if (temp.cascadeIndex < 4)
					shadowVolume = temp;
				
				isCascadeVisible *= visible;
			}
			//isCascadeVisible *= (isCascadeVisible > 0)? isCascadeVisibleInShadowmap(i, shadowVolume.cascadeIndex, clipMin, clipMax, tID): 1;
			//isCascadeVisible = isInFrustum;
			
			cascadeVisible[i] = isCascadeVisible;
			isVisible += cascadeVisible[i];
		}

		// Do we pass the shadow occlusion culling in camera space?
		//_debugBuffer[tID].minMaxXYInCameraSpace.xyz = shadowVolume.boundsCenter;
        if (isVisible > 0 && shadowVolume.cascadeIndex < 4)
            isVisible *= IsVisibleInDepthBuffer(shadowVolume, tID);
        
		//isVisible *= (((shadowVolume.cascadeIndex < 4) && (shadowVolume.cascadeIndex >= 0))? (IsVisibleInDepthBuffer(shadowVolume, tID)): 1);
		
		//_debugBuffer[tID].mipmapShadowmap.w = shadowVolume.cascadeIndex;
		//_debugBuffer[tID].minMaxXYInCameraSpace.xyz = shadowVolume.boundsExtents;
		_IsVisibleBuffer[tID] &= (1 << (_lightIndex + 1)) ^ 0xFFFFFFFF;
		_IsVisibleBuffer[tID] |= (isVisible > 0? 1: 0) << (_lightIndex + 1);
	}
	else
	{
		float3 clipMin, clipMax;
        uint isInFrustum = CalculateMinMaxWithLinearZ(boxCorners, _UNITY_MATRIX_VP1, clipMin, clipMax, tID);
		uint isVisible = 1;
		if (IsViewerOutsideObjBounds(_CamPosition, minPos, maxPos))
		{
			// Do we pass the frustum culling...?
			isVisible = isInFrustum;
            isVisible *= (isVisible > 0) ? isVisibleInDepthBuffer(clipMin, clipMax, tID) : 1;
        }
		_IsVisibleBuffer[tID] &= 1 ^ 0xFFFFFFFF;
		_IsVisibleBuffer[tID] |= isVisible;
	}
}
